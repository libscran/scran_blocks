<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_blocks: scran_blocks Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_blocks
   </div>
   <div id="projectbrief">Blocking utilities for libscran</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_blocks Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Blocking utilities for <b>libscran</b>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <code><a class="el" href="#a33ebed1decbfe3627ce4ddf0b99df825">compute_variable_weight()</a></code>.  <a href="structscran__blocks_1_1VariableWeightParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac2412948da94055ff438267ba089ba97" id="r_ac2412948da94055ff438267ba089ba97"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2412948da94055ff438267ba089ba97">WeightPolicy</a> : char { <b>NONE</b>
, <b>SIZE</b>
, <b>VARIABLE</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:ac2412948da94055ff438267ba089ba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad102233b847d4004e03035c29f243130" id="r_ad102233b847d4004e03035c29f243130"><td class="memTemplParams" colspan="2">template&lt;typename Stat_ , typename Output_ &gt; </td></tr>
<tr class="memitem:ad102233b847d4004e03035c29f243130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad102233b847d4004e03035c29f243130">average_vectors</a> (const std::size_t n, std::vector&lt; Stat_ * &gt; in, Output_ *const out, const bool skip_nan)</td></tr>
<tr class="separator:ad102233b847d4004e03035c29f243130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9262136b3895afe8b0217cfc51337c" id="r_afd9262136b3895afe8b0217cfc51337c"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Stat_ &gt; </td></tr>
<tr class="memitem:afd9262136b3895afe8b0217cfc51337c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd9262136b3895afe8b0217cfc51337c">average_vectors</a> (const std::size_t n, std::vector&lt; Stat_ * &gt; in, const bool skip_nan)</td></tr>
<tr class="separator:afd9262136b3895afe8b0217cfc51337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa41c174fefddebe4fc45c593f4edd2e" id="r_afa41c174fefddebe4fc45c593f4edd2e"><td class="memTemplParams" colspan="2">template&lt;typename Stat_ , typename Weight_ , typename Output_ &gt; </td></tr>
<tr class="memitem:afa41c174fefddebe4fc45c593f4edd2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa41c174fefddebe4fc45c593f4edd2e">average_vectors_weighted</a> (const std::size_t n, std::vector&lt; Stat_ * &gt; in, const Weight_ *const w, Output_ *const out, const bool skip_nan)</td></tr>
<tr class="separator:afa41c174fefddebe4fc45c593f4edd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681cdd5f36d39f2e26f7a155551d259" id="r_ac681cdd5f36d39f2e26f7a155551d259"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = double, typename Stat_ , typename Weight_ &gt; </td></tr>
<tr class="memitem:ac681cdd5f36d39f2e26f7a155551d259"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac681cdd5f36d39f2e26f7a155551d259">average_vectors_weighted</a> (const std::size_t n, std::vector&lt; Stat_ * &gt; in, const Weight_ *const w, const bool skip_nan)</td></tr>
<tr class="separator:ac681cdd5f36d39f2e26f7a155551d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ebed1decbfe3627ce4ddf0b99df825" id="r_a33ebed1decbfe3627ce4ddf0b99df825"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ebed1decbfe3627ce4ddf0b99df825">compute_variable_weight</a> (const double s, const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;params)</td></tr>
<tr class="separator:a33ebed1decbfe3627ce4ddf0b99df825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb0ccb73289d97436afd94824ec0fae" id="r_a2eb0ccb73289d97436afd94824ec0fae"><td class="memTemplParams" colspan="2">template&lt;typename Size_ , typename Weight_ &gt; </td></tr>
<tr class="memitem:a2eb0ccb73289d97436afd94824ec0fae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eb0ccb73289d97436afd94824ec0fae">compute_weights</a> (const std::size_t num_blocks, const Size_ *const sizes, const <a class="el" href="#ac2412948da94055ff438267ba089ba97">WeightPolicy</a> policy, const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;variable, Weight_ *const weights)</td></tr>
<tr class="separator:a2eb0ccb73289d97436afd94824ec0fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b74f7588264fae43fa06015f045c7" id="r_a182b74f7588264fae43fa06015f045c7"><td class="memTemplParams" colspan="2">template&lt;typename Weight_  = double, typename Size_ &gt; </td></tr>
<tr class="memitem:a182b74f7588264fae43fa06015f045c7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Weight_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a182b74f7588264fae43fa06015f045c7">compute_weights</a> (const std::vector&lt; Size_ &gt; &amp;sizes, const <a class="el" href="#ac2412948da94055ff438267ba089ba97">WeightPolicy</a> policy, const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;variable)</td></tr>
<tr class="separator:a182b74f7588264fae43fa06015f045c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a482389174be65d7c964b8c57a53589" id="r_a6a482389174be65d7c964b8c57a53589"><td class="memTemplParams" colspan="2"><a id="a6a482389174be65d7c964b8c57a53589" name="a6a482389174be65d7c964b8c57a53589"></a>
template&lt;typename Input_ &gt; </td></tr>
<tr class="memitem:a6a482389174be65d7c964b8c57a53589"><td class="memTemplItemLeft" align="right" valign="top">std::remove_cv_t&lt; std::remove_reference_t&lt; Input_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>I</b> (Input_ x)</td></tr>
<tr class="separator:a6a482389174be65d7c964b8c57a53589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Blocking utilities for <b>libscran</b>. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac2412948da94055ff438267ba089ba97" name="ac2412948da94055ff438267ba089ba97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2412948da94055ff438267ba089ba97">&#9670;&#160;</a></span>WeightPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac2412948da94055ff438267ba089ba97">scran_blocks::WeightPolicy</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy for weighting blocks based on their size, i.e., the number of cells in each block. This determines the nature of the weight calculations in <code><a class="el" href="#a2eb0ccb73289d97436afd94824ec0fae">compute_weights()</a></code>.</p>
<ul>
<li><code>SIZE</code>: blocks are weighted in proportion to their size. Larger blocks will contribute more to the weighted average.</li>
<li><code>EQUAL</code>: each non-empty block is assigned equal weight, regardless of its size. Equivalent to averaging across non-empty blocks without weights.</li>
<li><code>VARIABLE</code>: each batch is weighted using the logic in <code><a class="el" href="#a33ebed1decbfe3627ce4ddf0b99df825">compute_variable_weight()</a></code>. This penalizes small blocks with unreliable statistics while equally weighting all large blocks.</li>
<li><code>NONE</code>: a deprecated alias for <code>SIZE</code>. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afd9262136b3895afe8b0217cfc51337c" name="afd9262136b3895afe8b0217cfc51337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9262136b3895afe8b0217cfc51337c">&#9670;&#160;</a></span>average_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Stat_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran_blocks::average_vectors </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code>compute()</code> that allocates an output vector of averaged values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Floating-point output type. </td></tr>
    <tr><td class="paramname">Stat</td><td>Type of the input statistic, typically floating point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">skip_nan</td><td>Whether to check for NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length <code>n</code> is returned, containing the average of all arrays in <code>in</code>. Specifically, the <code>i</code>-th entry is set to the average of the <code>i</code>-th entry across all <code>in</code> arrays. </dd></dl>

</div>
</div>
<a id="ad102233b847d4004e03035c29f243130" name="ad102233b847d4004e03035c29f243130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad102233b847d4004e03035c29f243130">&#9670;&#160;</a></span>average_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_blocks::average_vectors </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *const</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average parallel elements across multiple arrays. This is equivalent to calling <code>average_weighted_vectors()</code> with equal weights for each array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point. </td></tr>
    <tr><td class="paramname">Output_</td><td>Floating-point output type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to an output array of length <code>n</code>. On completion, <code>out</code> is filled with the average of all arrays in <code>in</code>. Specifically, the <code>i</code>-th entry of <code>out</code> is set to the average of the <code>i</code>-th entry across all <code>in</code> arrays. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">skip_nan</td><td>Whether to check for NaNs. If <code>true</code>, NaNs are ignored in the average calculations for each element, at the cost of some efficiency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac681cdd5f36d39f2e26f7a155551d259" name="ac681cdd5f36d39f2e26f7a155551d259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac681cdd5f36d39f2e26f7a155551d259">&#9670;&#160;</a></span>average_vectors_weighted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = double, typename Stat_ , typename Weight_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran_blocks::average_vectors_weighted </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weight_ *const</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#afa41c174fefddebe4fc45c593f4edd2e">average_vectors_weighted()</a></code> that allocates an output vector of averaged values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Floating-point output type. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Type of the weight, typically floating point. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of the same length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Pointer to an array of length equal to <code>in.size()</code>, containing the weight to use for each input array. Weights should be non-negative and finite. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">skip_nan</td><td>Whether to check for NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector is returned containing with the average of all arrays in <code>in</code>. </dd></dl>

</div>
</div>
<a id="afa41c174fefddebe4fc45c593f4edd2e" name="afa41c174fefddebe4fc45c593f4edd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa41c174fefddebe4fc45c593f4edd2e">&#9670;&#160;</a></span>average_vectors_weighted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_ , typename Weight_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_blocks::average_vectors_weighted </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weight_ *const</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *const</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a weighted average of parallel elements across multiple arrays. For example, we can average statistics across blocks using weights computed with <code><a class="el" href="#a2eb0ccb73289d97436afd94824ec0fae">compute_weights()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Type of the weight, typically floating point. </td></tr>
    <tr><td class="paramname">Output_</td><td>Floating-point output type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Pointer to an array of length equal to <code>in.size()</code>, containing the weight to use for each input array. Weights should be non-negative and finite. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to an output array of length <code>n</code>. On output, <code>out</code> is filled with the weighted average of all arrays in <code>in</code>. Specifically, the <code>i</code>-th entry of <code>out</code> is set to the average of the <code>i</code>-th entry across all <code>in</code> arrays. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">skip_nan</td><td>Whether to check for NaNs. If <code>true</code>, NaNs are ignored in the average calculations for each element, at the cost of some efficiency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33ebed1decbfe3627ce4ddf0b99df825" name="a33ebed1decbfe3627ce4ddf0b99df825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ebed1decbfe3627ce4ddf0b99df825">&#9670;&#160;</a></span>compute_variable_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double scran_blocks::compute_variable_weight </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a variable weight to each block of cells, for use in computing a weighted average across blocks. The weight for each block is calculated from the size of that block.</p>
<ul>
<li>If the block size is less than <code><a class="el" href="structscran__blocks_1_1VariableWeightParameters.html#a0c21095e5569208fa946c7f1b5791ea5">VariableWeightParameters::lower_bound</a></code>, it has zero weight.</li>
<li>If the block size is greater than <code><a class="el" href="structscran__blocks_1_1VariableWeightParameters.html#a865b484b6fc8611048fcadab863de6bf">VariableWeightParameters::upper_bound</a></code>, it has weight of 1.</li>
<li>Otherwise, the block has weight proportional to its size, increasing linearly from 0 to 1 between the two bounds.</li>
</ul>
<p>Blocks that are "large enough" (i.e., above the upper bound) are considered to be equally trustworthy and receive the same weight, ensuring that each block contributes equally to the weighted average. By comparison, very small blocks receive lower weight as their statistics are generally less stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Size of the block, in terms of the number of cells in that block. </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for the weight calculation, consisting of the lower and upper bounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Weight of the block, to use for computing a weighted average across blocks. </dd></dl>

</div>
</div>
<a id="a2eb0ccb73289d97436afd94824ec0fae" name="a2eb0ccb73289d97436afd94824ec0fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb0ccb73289d97436afd94824ec0fae">&#9670;&#160;</a></span>compute_weights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size_ , typename Weight_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_blocks::compute_weights </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Size_ *const</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac2412948da94055ff438267ba089ba97">WeightPolicy</a></td>          <td class="paramname"><span class="paramname"><em>policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>variable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Weight_ *const</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute weights for multiple blocks based on their size and the weighting policy. For variable weights, this function will call <code><a class="el" href="#a33ebed1decbfe3627ce4ddf0b99df825">compute_variable_weight()</a></code> for each block.</p>
<p>Weights should be interpreted as relative values within a single <code><a class="el" href="#a2eb0ccb73289d97436afd94824ec0fae">compute_weights()</a></code> call, i.e., weights from different calls may not be comparable. They are typically used in functions like <code>average_weighted_vectors()</code> to compute a weighted average of statistics across blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size_</td><td>Numeric type of the block size. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type of the output weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_blocks</td><td>Number of blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Pointer to an array of length <code>num_blocks</code>, containing the size of each block. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">policy</td><td>Policy for weighting blocks of different sizes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">variable</td><td>Parameters for the variable block weights. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">weights</td><td>Pointer to an array of length <code>num_blocks</code>. On output, this is filled with the weight of each block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a182b74f7588264fae43fa06015f045c7" name="a182b74f7588264fae43fa06015f045c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182b74f7588264fae43fa06015f045c7">&#9670;&#160;</a></span>compute_weights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Weight_  = double, typename Size_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Weight_ &gt; scran_blocks::compute_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Size_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac2412948da94055ff438267ba089ba97">WeightPolicy</a></td>          <td class="paramname"><span class="paramname"><em>policy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__blocks_1_1VariableWeightParameters.html">VariableWeightParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>variable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience overload for <code><a class="el" href="#a2eb0ccb73289d97436afd94824ec0fae">compute_weights()</a></code> that accepts and returns vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size_</td><td>Numeric type of the block size. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type of the output weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector containing the size of each block. </td></tr>
    <tr><td class="paramname">policy</td><td>Policy for weighting blocks of different sizes. </td></tr>
    <tr><td class="paramname">variable</td><td>Parameters for the variable block weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of block weights. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
